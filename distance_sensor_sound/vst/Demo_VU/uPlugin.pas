unit uPlugin;

interface
uses Windows, uEditor, DAEffect, DAEffectX,
     DAudioEffect, DAudioEffectX, DVstTemplate, Forms,
     DVstUtils, Math, DDspUtils, Sysutils;

type
 APlugin = class(TVstTemplate)
 public
  peak_l, peak_r, vol_l, vol_r: single;
  procedure processMIDI(ev: VstMidiEvent); override;
  procedure initializeParameters; override;
  procedure parameterChanged(Index: Integer);
  procedure processAudio(const inputs, outputs: TArrayOfSingleArray;
   sampleframes: Integer); override;
  constructor Create(audioMaster: TAudioMasterCallbackFunc);
  procedure editorIdle(Sender: TObject);
 end;

implementation

constructor APlugin.Create(audioMaster: TAudioMasterCallbackFunc);
var numPrograms, numParameters: integer;
begin
 // define what the plugin "can do"
 // the following canDos are defined:
 { sendVstEvents, sendVstMidiEvent, sendVstTimeInfo,
   receiveVstEvents, receiveVstMidiEvent, receiveVstTimeInfo,
   offline, plugAsChannelInsert, plugAsSend, mixDryWet, noRealTime,
   multipass, metapass, _1in1out, _1in2out, _2in1out, _2in2out,
   _2in4out, _4in2out, _4in4out, _4in8out, _8in4out, _8in8out,
   midiProgramNames, conformsToWindowRules, bypass }
 canDos := [receiveVstEvents, receiveVstMidiEvent,
  sendVstEvents, sendVstMidiEvent];

 // define some plugin properties
 { prIsSynth, prHasVu, prHasClip, prCanMono,
   prCanReplacing, prProgramsAreChunks,
   prNoSoundinStop, prIsAsync, prExtHasBuffer }
 Properties := [prCanMono, prCanReplacing];

 // define number of audio inputs and outputs
 numInputs := 2;
 numOutputs := 2;

 // define number of programs and parameters
 numPrograms := 1;
 numParameters := 2;

 // define the buffer size
 BufferSize := 512;

 // set the unique ID for this plugin,
 // change this for every new plugin you make!
 UniqueID := 'ABCD';

 // more plugin ID settings
 EffectName := 'TestPlugin';
 ProductName := 'TestPlugin';
 VendorName := 'Tobybear';
 VendorVersion := 1;

 // define the delay (in samples) that the plugin produces (if any)
 // this is necessary for latency compensation in the host
 initialDelay := 0;

 // You can replace "TPluginEditorWindow" with "nil" if you do not want an own
 // editor window and use the host's default representation
 inherited Create(audiomaster, numPrograms, numParameters, TPluginEditorWindow);

 // connect event handlers 
 OnParameterChange := ParameterChanged;
 OnEditorIdle := EditorIdle;
end;

procedure APlugin.initializeParameters;
begin
 // Here you can define the properties for each parameter.
 // This is however optional, if you don't define anything
 // a default linear mapping of 0..1 wil be assumed.

 ParameterProperties[0].min := -90;
 ParameterProperties[0].max := 0;
 ParameterProperties[0].name := 'Volume Left';
 ParameterProperties[0].units := 'dB(fs)';
 ParameterProperties[0].curve := ctExponential;
 ParameterProperties[0].curveFactor := 1000;

 ParameterProperties[1].min := -90;
 ParameterProperties[1].max := 0;
 ParameterProperties[1].name := 'Volume Right';
 ParameterProperties[1].units := 'dB(fs)';
 ParameterProperties[1].curve := ctExponential;
 ParameterProperties[1].curveFactor := 1000;

 // Here are 2 ways to set the parameters:

 // 1. using the regular VST setParameter function
 // parameter 0 is set to "1", the value always has to be in range 0..1!
 setParameter(0, 1);

 // 2. using the setParameterEx function
 // value can be in the range of the min/max properties defined
 // for that parameter
 setParameterEx(1, 0);

 // both calls have the same function in the above example: setting
 // the default volume setting to maximum.
 // The first method sets parameter 0 to maximum ("1" equals 100%).
 // The second method sets parameter 1 to a value of 0 dB(fs).
end;

// This procedure is for processing VST MIDI input and output.
// MIDI input could be processed as shown in the example below,
// MIDI output can be generated by calling one of the MIDI_*
// procedures (look in DVstTemplate.pas for them).
procedure APlugin.processMIDI(ev: VstMidiEvent);
var time, data1, data2, status, channel: integer;
begin
 channel := ev.midiData[0] and $0F;
 status := ev.midiData[0] and $F0;
 data1 := ev.midiData[1] and $7F;
 data2 := ev.midiData[2] and $7F;
 time := ev.deltaFrames;

 // example MIDI code:
 if (status = $90) and (data2 > 0) then // "Note On" ?
 begin
  // data1 contains note number
  // data2 contains note velocity
  // send "Note On" back to host (MIDI thru)
  MIDI_NoteOn(channel, data1, data2, time);
 end
 else if ((status = $90) and (data2 = 0)) or
  (status = $80) then // "Note Off" ?
 begin
  // data1 contains note number
  // data2 contains note off velocity
  // send "Note Off" back to host (MIDI thru)
  MIDI_NoteOff(channel, data1, data2, time);
 end
 else if (status = $A0) then // "Polyphonic Aftertouch" ?
 begin
  // data1 contains note number
  // data2 contains aftertouch value
 end
 else if (status = $B0) then // "MIDI Controller" ?
 begin
  // data1 contains CC number
  // data2 contains data value
 end
 else if (status = $C0) then // "Program Change" ?
 begin
  // data1 contains program number
 end
 else if (status = $D0) then // "Channel Aftertouch" ?
 begin
  // data1 contains channel aftertouch value
 end
 else if (status = $E0) then // "Pitchbend" ?
 begin
  // data1 and data2 make up the 12 bit pitchbend value
 end;
end;

procedure APlugin.parameterChanged(Index: Integer);
begin
 // This procedure gets called whenever a parameter (index) is
 // changed to a new value. You can then react accordingly.
 if (Index = 0) then
 begin
  vol_l := power(10, (getParameterEx(0) / 20));
 end else
 if (Index = 1) then
 begin
  vol_r := power(10, (getParameterEx(1) / 20));
 end;
end;

procedure APlugin.editorIdle(Sender: TObject);
begin
 // Here you can directly access the editor form from the plugin.
 // In this example, the VU data and the current gains are displayed
 with (Sender as TPluginEditorWindow) do
 begin
  vu_l.Width := round(peak_l * 300);
  vu_r.Width := round(peak_r * 300);
  gain_l.Caption := 'left gain: ' + inttostr(round(getParameterEx(0))) + ' db(fs)';
  gain_r.Caption := 'right gain: ' + inttostr(round(getParameterEx(1))) + ' db(fs)';
 end;
end;

procedure APlugin.processAudio(const inputs, outputs: TArrayOfSingleArray;
  sampleframes: Integer);
var i: integer;
    tmp_l, tmp_r: single;
begin
 // This is usually the most important part of your plugin:
 // Here the samples for each input and output channel can be processed
 // individually. In this example, the volume of the left and right
 // channel is set by variables determined by the parameters 0 and 1,
 // that were pre-calculated and stored in the variables vol_l and vol_r
 // in the parameterChanged procedure.
 // There is also a simple VU meter code here for calculating the average
 // energy for a 512 sample block.
 tmp_l := 0;
 tmp_r := 0;
 for i := 0 to sampleframes - 1 do
 begin
  outputs[0, i] := inputs[0, i] * vol_l;
  outputs[1, i] := inputs[1, i] * vol_r;
  // simple (but not very efficient) VU meter code:
  tmp_l := tmp_l + f_abs(outputs[0, i]);
  tmp_r := tmp_r + f_abs(outputs[1, i]);
 end;
 peak_l := 0.8 * peak_l + 0.2 * (tmp_l / BufferSize);
 peak_r := 0.8 * peak_r + 0.2 * (tmp_r / BufferSize);
end;

end.


