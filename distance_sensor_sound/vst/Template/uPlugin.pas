unit uPlugin;

interface
uses Windows, uEditor, DAEffect, DAEffectX,
     DAudioEffect, DAudioEffectX, DVstTemplate, Forms,
     DVstUtils, Math, DDspUtils, Sysutils;

type
 APlugin = class(TVstTemplate)
 public
  procedure processMIDI(ev: VstMidiEvent); override;
  procedure initializeParameters; override;
  procedure parameterChanged(Index: Integer);
  procedure processAudio(const inputs, outputs: TArrayOfSingleArray;
   sampleframes: Integer); override;
  constructor Create(audioMaster: TAudioMasterCallbackFunc);
  procedure editorIdle(Sender: TObject);
 end;

implementation

constructor APlugin.Create(audioMaster: TAudioMasterCallbackFunc);
var numPrograms, numParameters: integer;
begin
 // define what the plugin "can do"
 // the following canDos are defined:
 { sendVstEvents, sendVstMidiEvent, sendVstTimeInfo,
   receiveVstEvents, receiveVstMidiEvent, receiveVstTimeInfo,
   offline, plugAsChannelInsert, plugAsSend, mixDryWet, noRealTime,
   multipass, metapass, _1in1out, _1in2out, _2in1out, _2in2out,
   _2in4out, _4in2out, _4in4out, _4in8out, _8in4out, _8in8out,
   midiProgramNames, conformsToWindowRules, bypass }
 canDos := [receiveVstEvents, receiveVstMidiEvent,
  sendVstEvents, sendVstMidiEvent];

 // define some plugin properties
 { prIsSynth, prHasVu, prHasClip, prCanMono,
   prCanReplacing, prProgramsAreChunks,
   prNoSoundinStop, prIsAsync, prExtHasBuffer }
 Properties := [prCanMono, prCanReplacing];

 // define number of audio inputs and outputs
 numInputs := 2;
 numOutputs := 2;

 // define number of programs and parameters
 numPrograms := 1;
 numParameters := 3;

 // set the unique ID for this plugin,
 // change this for every new plugin you make!
 UniqueID := 'ABCF';

 // more plugin ID settings
 EffectName := 'TestPlugin';
 ProductName := 'TestPlugin';
 VendorName := 'Tobybear';
 VendorVersion := 1;

 // define the delay (in samples) that the plugin produces (if any)
 // this is necessary for latency compensation in the host
 initialDelay := 0;

 // You can replace "TPluginEditorWindow" with "nil" if you do not want an own
 // editor window and use the host's default representation
 inherited Create(audiomaster, numPrograms, numParameters, TPluginEditorWindow);

 // connect event handlers 
 OnParameterChange := ParameterChanged;
 OnEditorIdle := EditorIdle;
end;

procedure APlugin.initializeParameters;
begin
 // initialize your parameters here:

 // just an example:
 setParameter(0, 1);
 setParameter(1, 0.5);
 setParameter(2, 0);
end;

// This procedure is for processing VST MIDI input and output.
// MIDI input could be processed as shown in the example below,
// MIDI output can be generated by calling one of the MIDI_*
// procedures (look in DVstTemplate.pas for them).
procedure APlugin.processMIDI(ev: VstMidiEvent);
var time, data1, data2, status, channel: integer;
begin
 // decode MIDI info like channel, status and data bytes
 channel := ev.midiData[0] and $0F;
 status := ev.midiData[0] and $F0;
 data1 := ev.midiData[1] and $7F;
 data2 := ev.midiData[2] and $7F;
 time := ev.deltaFrames;

 // example MIDI code:
 if (status = $90) and (data2 > 0) then // "Note On" ?
 begin
  // data1 contains note number, data2 contains note velocity
  // send "Note On" back to host (MIDI thru)
  MIDI_NoteOn(channel, data1, data2, time);
 end
 else if ((status = $90) and (data2 = 0)) or
  (status = $80) then // "Note Off" ?
 begin
  // data1 contains note number, data2 contains note off velocity
  // send "Note Off" back to host (MIDI thru)
  MIDI_NoteOff(channel, data1, data2, time);
 end;
end;

procedure APlugin.parameterChanged(Index: Integer);
begin
 // This procedure gets called whenever a parameter (index) is
 // changed to a new value. You can then react accordingly.
 // if (Index = 0) then ...
 // else if (Index = 1) then ...
end;

procedure APlugin.editorIdle(Sender: TObject);
begin
 // Here you can directly access the editor form from the plugin.
 // with (Sender as TPluginEditorWindow) do ...
end;

procedure APlugin.processAudio(const inputs, outputs: TArrayOfSingleArray;
  sampleframes: Integer);
var i: integer;
begin
 // This is usually the most important part of your plugin:
 // Here the samples for each input and output channel can be processed
 for i := 0 to sampleframes - 1 do
 begin
  // in this example, we just pass through the audio data
  outputs[0, i] := inputs[0, i];
  outputs[1, i] := inputs[1, i];
 end;
end;

end.


